<!DOCTYPE html>
<html lang="en">

<head>
    <title>three.js xr - AR Controller</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <link type="text/css" rel="stylesheet" href="/static/css/main.css">
</head>

<body>
    <div id="info">
        <a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> xr - AR Controller
    </div>

    <script type="importmap">
            {
                "imports": {
                    "three": "/static/build/three.module.js",
                    "three/addons/": "/static/jsm/"
                }
            }
        </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { XRButton } from 'three/addons/webxr/XRButton.js';

        let camera, scene, renderer;
        let controller1, controller2;
        const socket = new WebSocket('wss://' + window.location.host + '/ws');
        let xrCamera = null;
        let controls;

        init();

        function init() {
            const container = document.createElement('div');
            document.body.appendChild(container);

            scene = new THREE.Scene();
            // 移除背景色，使其透明
            scene.background = null;

            // 调整相机参数以适应AR场景
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);
            camera.position.set(0, 1.6, 3);

            // 保留OrbitControls用于调试
            controls = new OrbitControls(camera, container);
            controls.target.set(0, 1.6, 0);
            controls.update();

            // 移除网格，添加适合AR的光照
            const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
            light.position.set(0.5, 1, 0.25);
            scene.add(light);

            // 配置渲染器支持AR透视
            renderer = new THREE.WebGLRenderer({ 
                antialias: true,
                alpha: true  // 启用透明
            });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setAnimationLoop(animate);
            renderer.xr.enabled = true;
            container.appendChild(renderer.domElement);

            // 配置XR会话
            const sessionInit = {
                requiredFeatures: ['hit-test'],
                optionalFeatures: ['dom-overlay'],
                domOverlay: { root: document.body }
            };

            document.body.appendChild(XRButton.createButton(renderer, sessionInit));

            renderer.xr.addEventListener('sessionstart', () => {
                xrCamera = renderer.xr.getCamera();
            });

            // Setup controllers
            controller1 = renderer.xr.getController(0);
            controller2 = renderer.xr.getController(1);

            // Controller setup and event listeners
            [controller1, controller2].forEach((controller, index) => {
                controller.addEventListener('connected', function (event) {
                    console.log(`Controller ${index + 1} connected:`, event.data);
                    controller.gamepad = event.data.gamepad;
                });

                controller.addEventListener('disconnected', function () {
                    console.log(`Controller ${index + 1} disconnected`);
                    controller.gamepad = null;
                });

                scene.add(controller);
            });

            // Send controller data
            setInterval(() => {
                const controllersData = {
                    type: 'controllers_state',
                    data: {}
                };

                [controller1, controller2].forEach((controller, index) => {
                    if (controller && controller.gamepad) {
                        const position = new THREE.Vector3();
                        const rotation = new THREE.Euler();
                        position.setFromMatrixPosition(controller.matrixWorld);
                        rotation.setFromRotationMatrix(controller.matrixWorld);

                        controllersData.data[`controller${index + 1}`] = {
                            position: {
                                x: parseFloat(position.x.toFixed(2)),
                                y: parseFloat(position.y.toFixed(2)),
                                z: parseFloat(position.z.toFixed(2))
                            },
                            rotation: {
                                x: parseFloat(rotation.x.toFixed(2)),
                                y: parseFloat(rotation.y.toFixed(2)),
                                z: parseFloat(rotation.z.toFixed(2))
                            },
                            buttons: controller.gamepad.buttons.map(b => b.pressed),
                            axes: Array.from(controller.gamepad.axes)
                        };
                    }
                });

                socket.send(JSON.stringify(controllersData));
            }, 100);

            window.addEventListener('resize', onWindowResize);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
