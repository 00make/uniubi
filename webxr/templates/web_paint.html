<!DOCTYPE html>
<html lang="en">

<head>
    <title>XR Controller</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <link type="text/css" rel="stylesheet" href="/static/css/main.css">
    <script src="/static/streamedian.min.js"></script>
</head>

<body>
    <div id="info">
        <a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> xr - AR Controller
    </div>
    <video id="rtsp-video" autoplay playsinline style="display: none;"></video>
    
    <!-- RTSP控制面板 -->
    <div id="rtsp-controls" style="position: fixed; top: 10px; right: 10px; z-index: 1000; background: rgba(0,0,0,0.8); padding: 10px; border-radius: 5px; color: white;">
        <input type="text" id="rtsp-url" placeholder="RTSP地址" value="rtsp://192.168.234.1:8554/test" style="width: 200px; margin-bottom: 5px;">
        <br>
        <button id="connect-rtsp" style="margin-right: 5px;">连接RTSP</button>
        <button id="toggle-video" style="background: #28a745;">显示视频</button>
    </div>
    <script type="importmap">
			{
				"imports": {
					"three": "/static/build/three.module.js",
					"three/addons/": "/static/jsm/"
				}
			}
		</script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { XRButton } from 'three/addons/webxr/XRButton.js';
        let camera, scene, renderer;
        let controller1, controller2;
        let videoTexture, videoMaterial, videoPlane;
        const socket = new WebSocket('wss://' + window.location.host + '/ws');
        let xrCamera = null;
        let controls;
        let player = null;
        let videoVisible = false;
        
        async function initRTSP() {
            try {
                const video = document.getElementById('rtsp-video');
                
                videoTexture = new THREE.VideoTexture(video);
                videoTexture.minFilter = THREE.LinearFilter;
                videoTexture.magFilter = THREE.LinearFilter;
                videoMaterial = new THREE.MeshBasicMaterial({
                    map: videoTexture,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.8
                });
                const planeGeometry = new THREE.PlaneGeometry(1.6, 0.9);
                videoPlane = new THREE.Mesh(planeGeometry, videoMaterial);
                videoPlane.position.set(0, 0, -1);
                videoPlane.visible = false; // 初始隐藏
                scene.add(videoPlane);
                
                console.log('RTSP视频平面已创建');
            } catch (error) {
                console.error('初始化RTSP失败:', error);
            }
        }
        
        function connectRTSP() {
            const url = document.getElementById('rtsp-url').value.trim();
            const video = document.getElementById('rtsp-video');
            
            if (!url) {
                alert('请输入RTSP地址');
                return;
            }
            
            // 停止之前的播放
            if (player) {
                try {
                    player.destroy();
                } catch (e) {
                    console.warn('销毁播放器失败:', e);
                }
                player = null;
            }
            
            try {
                // 设置视频源
                video.src = url;
                
                // 如果有Streamedian库，使用它
                if (window.Streamedian) {
                    player = Streamedian.player('rtsp-video', {
                        socket: "ws://localhost:8088/ws/",
                        bufferDuration: 20,
                        errorHandler: function (error) {
                            console.error('RTSP播放错误:', error);
                        }
                    });
                }
                
                console.log('RTSP连接成功:', url);
            } catch (error) {
                console.error('RTSP连接失败:', error);
                alert('RTSP连接失败: ' + error.message);
            }
        }
        
        function toggleVideoVisibility() {
            videoVisible = !videoVisible;
            const button = document.getElementById('toggle-video');
            
            if (videoPlane) {
                videoPlane.visible = videoVisible;
            }
            
            if (videoVisible) {
                button.textContent = '隐藏视频';
                button.style.background = '#dc3545';
            } else {
                button.textContent = '显示视频';
                button.style.background = '#28a745';
            }
            
            console.log('视频显示状态:', videoVisible);
        }
        init();
        function init() {
            const container = document.createElement('div');
            document.body.appendChild(container);
            scene = new THREE.Scene();
            // 移除背景色，使其透明
            scene.background = null;
            // 调整相机参数以适应AR场景
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);
            camera.position.set(0, 1.6, 3);
            // 保留OrbitControls用于调试
            controls = new OrbitControls(camera, container);
            controls.target.set(0, 1.6, 0);
            controls.update();
            // 移除网格，添加适合AR的光照
            const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
            light.position.set(0.5, 1, 0.25);
            scene.add(light);
            // 配置渲染器支持AR透视
            renderer = new THREE.WebGLRenderer({
                antialias: true,
                alpha: true  // 启用透明
            });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setAnimationLoop(animate);
            renderer.xr.enabled = true;
            container.appendChild(renderer.domElement);
            // 配置XR会话
            const sessionInit = {
                requiredFeatures: ['hit-test'],
                optionalFeatures: ['dom-overlay'],
                domOverlay: { root: document.body }
            };
            document.body.appendChild(XRButton.createButton(renderer, sessionInit));
            renderer.xr.addEventListener('sessionstart', () => {
                xrCamera = renderer.xr.getCamera();
            });
            // Setup controllers
            controller1 = renderer.xr.getController(0);
            controller2 = renderer.xr.getController(1);
            // Controller setup and event listeners
            [controller1, controller2].forEach((controller, index) => {
                controller.addEventListener('connected', function (event) {
                    console.log(`Controller ${index + 1} connected:`, event.data);
                    controller.gamepad = event.data.gamepad;
                });
                controller.addEventListener('disconnected', function () {
                    console.log(`Controller ${index + 1} disconnected`);
                    controller.gamepad = null;
                });
                scene.add(controller);
            });
            // Send controller data
            setInterval(() => {
                const controllersData = {
                    type: 'controllers_state',
                    data: {}
                };
                [controller1, controller2].forEach((controller, index) => {
                    if (controller && controller.gamepad) {
                        const position = new THREE.Vector3();
                        const rotation = new THREE.Euler();
                        position.setFromMatrixPosition(controller.matrixWorld);
                        rotation.setFromRotationMatrix(controller.matrixWorld);
                        controllersData.data[`controller${index + 1}`] = {
                            position: {
                                x: parseFloat(position.x.toFixed(2)),
                                y: parseFloat(position.y.toFixed(2)),
                                z: parseFloat(position.z.toFixed(2))
                            },
                            rotation: {
                                x: parseFloat(rotation.x.toFixed(2)),
                                y: parseFloat(rotation.y.toFixed(2)),
                                z: parseFloat(rotation.z.toFixed(2))
                            },
                            buttons: controller.gamepad.buttons.map(b => b.pressed),
                            axes: Array.from(controller.gamepad.axes)
                        };
                    }
                });
                socket.send(JSON.stringify(controllersData));
            }, 100);
            window.addEventListener('resize', onWindowResize);
            
            // 添加事件监听器
            document.getElementById('connect-rtsp').addEventListener('click', connectRTSP);
            document.getElementById('toggle-video').addEventListener('click', toggleVideoVisibility);
            
            initRTSP();
        }
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        function animate() {
            if (videoTexture) {
                videoTexture.needsUpdate = true;
            }
            if (xrCamera && videoPlane) {
                const cameraPosition = new THREE.Vector3();
                const cameraQuaternion = new THREE.Quaternion();

                xrCamera.getWorldPosition(cameraPosition);
                xrCamera.getWorldQuaternion(cameraQuaternion);
                videoPlane.position.copy(cameraPosition);
                videoPlane.quaternion.copy(cameraQuaternion);
                videoPlane.translateZ(-1);
            }
            renderer.render(scene, camera);
        }
    </script>
</body>

</html>