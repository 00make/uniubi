# Piper机械臂重力补偿详细调参指南

## 调参理论基础

### 1. 重力补偿原理深入分析

重力补偿的核心是计算每个关节在当前姿态下需要克服的重力力矩：

```
τ_gravity = Σ(m_i * g * r_i × z_axis)
```

其中：

- `m_i`: 连杆i的质量
- `g`: 重力加速度向量
- `r_i`: 从关节轴心到连杆质心的向量
- `z_axis`: 关节转动轴方向

### 2. 简化模型的数学表达

对于Piper机械臂，简化的重力补偿模型为：

```python
# 关节2 (肩部) - 主要承重关节
τ2 = base_torque2 * sin(θ2 + π/2) * pos_factor2

# 关节3 (手臂) - 受关节2影响
τ3 = base_torque3 * sin(θ2 + θ3) * pos_factor3

# 关节4 (前臂) - 受前面关节影响
τ4 = base_torque4 * sin(θ2 + θ3) * pos_factor4
```

## 详细调参方法

### 1. 系统性调参流程

#### 第一阶段：安全初始化

```python
# 初始安全参数 (保守设置)
initial_params = {
    1: {"base_torque": 0.0, "pos_factor": 0.0},   # 基座旋转，无重力影响
    2: {"base_torque": 1.0, "pos_factor": 0.5},   # 肩部，从小开始
    3: {"base_torque": 0.5, "pos_factor": 0.3},   # 手臂，从小开始
    4: {"base_torque": 0.2, "pos_factor": 0.2},   # 前臂，微调
    5: {"base_torque": 0.0, "pos_factor": 0.0},   # 腕部旋转
    6: {"base_torque": 0.0, "pos_factor": 0.0}    # 末端旋转
}
compensation_gain = 0.3  # 整体增益从小开始
```

#### 第二阶段：关节2调参 (最关键)

**步骤1：确定base_torque2**

```python
# 测试步骤：
# 1. 将机械臂移动到水平位置 (θ2 ≈ 0°)
# 2. 观察机械臂下垂趋势
# 3. 逐步增加base_torque2直到基本平衡

测试位置序列 = [
    "水平位置 (θ2=0°)",      # sin(θ2+π/2) = 1, 最大力矩需求
    "垂直向上 (θ2=90°)",     # sin(θ2+π/2) = 0, 无力矩需求  
    "向下45° (θ2=-45°)",     # sin(θ2+π/2) = 0.707, 中等力矩需求
]

# 调节方法：
for position in 测试位置序列:
    print(f"移动到{position}")
    input("手动移动机械臂到该位置，按Enter继续...")
    
    # 观察现象并调整
    if "下垂明显":
        base_torque2 += 0.2
    elif "上抬明显": 
        base_torque2 -= 0.1
    elif "轻微振动":
        pos_factor2 -= 0.1  # 降低灵敏度
    else:
        print("该位置调节完成")
```

**步骤2：优化pos_factor2**

```python
# pos_factor影响力矩随角度的变化率
# 目标：在所有角度下都能保持平衡

角度测试点 = [-90°, -45°, 0°, 45°, 90°]

for angle in 角度测试点:
    print(f"测试角度: {angle}")
    # 如果某个角度下补偿过强/过弱，调整pos_factor
    if "角度敏感度过高":
        pos_factor2 -= 0.1
    elif "角度敏感度过低":
        pos_factor2 += 0.1
```

#### 第三阶段：关节3调参

```python
# 关节3受关节2影响，需要在不同θ2下测试
测试组合 = [
    (0°, 0°),    # θ2=0°, θ3=0°
    (0°, 45°),   # θ2=0°, θ3=45°
    (45°, 0°),   # θ2=45°, θ3=0°
    (45°, 45°),  # θ2=45°, θ3=45°
]

for θ2, θ3 in 测试组合:
    print(f"测试组合: θ2={θ2}, θ3={θ3}")
    # 调节base_torque3和pos_factor3
```

### 2. 经验参数范围

#### 不同负载下的参考参数

**标准负载 (无额外工具)**

```python
standard_params = {
    2: {"base_torque": 2.0-3.0, "pos_factor": 1.5-2.0},
    3: {"base_torque": 1.0-1.5, "pos_factor": 0.8-1.2},
    4: {"base_torque": 0.2-0.5, "pos_factor": 0.3-0.6},
}
```

**轻负载 (小工具 < 0.5kg)**

```python
light_load_params = {
    2: {"base_torque": 1.5-2.5, "pos_factor": 1.2-1.8},
    3: {"base_torque": 0.8-1.2, "pos_factor": 0.6-1.0},
    4: {"base_torque": 0.1-0.3, "pos_factor": 0.2-0.4},
}
```

**重负载 (工具 > 1kg)**

```python
heavy_load_params = {
    2: {"base_torque": 3.0-4.5, "pos_factor": 2.0-2.8},
    3: {"base_torque": 1.5-2.5, "pos_factor": 1.0-1.8},
    4: {"base_torque": 0.5-1.0, "pos_factor": 0.4-0.8},
}
```

### 3. 高级调参技巧

#### 技巧1：分区域调参法

```python
def zone_based_tuning():
    """基于工作区域的分区调参"""
    
    # 定义工作区域
    zones = {
        "前方伸展区": {"θ2_range": (-30, 30), "θ3_range": (0, 90)},
        "侧方工作区": {"θ2_range": (30, 90), "θ3_range": (-45, 45)},
        "收缩位置": {"θ2_range": (45, 90), "θ3_range": (-90, 0)},
    }
    
    # 每个区域单独优化
    for zone_name, zone_range in zones.items():
        print(f"优化{zone_name}...")
        # 在该区域内测试多个点
        # 记录最佳参数
        # 取平均值或加权平均
```

#### 技巧2：动态补偿系数

```python
def dynamic_compensation_factor(joint_angles, load_weight=0):
    """根据当前姿态和负载动态调整补偿系数"""
    
    θ2, θ3 = joint_angles[1], joint_angles[2]
    
    # 基础系数
    base_factor = 1.0
    
    # 根据姿态调整
    if abs(θ2) < 0.3:  # 接近水平
        base_factor *= 1.2
    elif abs(θ2) > 1.2:  # 接近垂直
        base_factor *= 0.8
    
    # 根据负载调整
    load_factor = 1.0 + load_weight * 0.3
    
    return base_factor * load_factor
```

#### 技巧3：自适应学习算法

```python
class AdaptiveGravityCompensation:
    def __init__(self):
        self.error_history = []
        self.param_history = []
        self.learning_rate = 0.01
    
    def update_parameters(self, current_error):
        """基于误差反馈自动调整参数"""
        
        self.error_history.append(current_error)
        
        if len(self.error_history) > 10:
            # 计算误差趋势
            error_trend = np.mean(self.error_history[-5:]) - np.mean(self.error_history[-10:-5])
            
            # 自适应调整
            if error_trend > 0.1:  # 误差增加
                self.reduce_compensation()
            elif error_trend < -0.1:  # 误差减少
                self.increase_compensation()
    
    def reduce_compensation(self):
        """减少补偿强度"""
        self.compensation_gain *= 0.95
    
    def increase_compensation(self):
        """增加补偿强度"""
        self.compensation_gain *= 1.05
```

## 调参工具和方法

### 1. 实时调参工具

创建一个实时调参界面：

```python
class RealTimeParameterTuner:
    def __init__(self, gravity_comp):
        self.gravity_comp = gravity_comp
        self.current_joint = 2  # 从关节2开始
        
    def interactive_tuning(self):
        """交互式实时调参"""
        print("=== 实时参数调节工具 ===")
        print("快捷键说明:")
        print("w/s: 增加/减少 base_torque")
        print("a/d: 增加/减少 pos_factor") 
        print("q/e: 增加/减少 compensation_gain")
        print("1-6: 切换关节")
        print("r: 重置当前关节参数")
        print("p: 打印当前参数")
        print("空格: 暂停/继续补偿")
        
        while True:
            # 显示当前状态
            self.display_status()
            
            # 获取用户输入
            key = input("输入命令: ").lower()
            
            if key == 'w':
                self.adjust_base_torque(0.1)
            elif key == 's':
                self.adjust_base_torque(-0.1)
            elif key == 'a':
                self.adjust_pos_factor(-0.05)
            elif key == 'd':
                self.adjust_pos_factor(0.05)
            elif key == 'q':
                self.adjust_gain(-0.05)
            elif key == 'e':
                self.adjust_gain(0.05)
            elif key in '123456':
                self.current_joint = int(key)
            elif key == 'r':
                self.reset_joint_params()
            elif key == 'p':
                self.print_all_params()
            elif key == ' ':
                self.toggle_compensation()
            elif key == 'quit':
                break
    
    def display_status(self):
        joint_angles = self.gravity_comp.get_joint_positions()
        print(f"\n当前关节角度: {[round(math.degrees(a), 1) for a in joint_angles]}")
        print(f"当前调节关节: {self.current_joint}")
        
        current_params = self.gravity_comp.gravity_compensation_params[self.current_joint]
        print(f"base_torque: {current_params['base_torque']:.2f}")
        print(f"pos_factor: {current_params['pos_factor']:.2f}")
        print(f"compensation_gain: {self.gravity_comp.compensation_gain:.2f}")
```

### 2. 数据记录和分析

```python
class ParameterLogger:
    def __init__(self):
        self.log_data = []
        
    def record_session(self, params, joint_angles, performance_score):
        """记录调参会话数据"""
        timestamp = time.time()
        self.log_data.append({
            'timestamp': timestamp,
            'parameters': params.copy(),
            'joint_angles': joint_angles.copy(),
            'performance_score': performance_score
        })
    
    def analyze_best_parameters(self):
        """分析最佳参数组合"""
        if not self.log_data:
            return None
            
        # 按性能评分排序
        sorted_data = sorted(self.log_data, key=lambda x: x['performance_score'], reverse=True)
        
        # 取前10%的数据
        top_10_percent = sorted_data[:max(1, len(sorted_data)//10)]
        
        # 计算平均参数
        avg_params = {}
        for joint_id in range(1, 7):
            avg_params[joint_id] = {
                'base_torque': np.mean([d['parameters'][joint_id]['base_torque'] for d in top_10_percent]),
                'pos_factor': np.mean([d['parameters'][joint_id]['pos_factor'] for d in top_10_percent])
            }
        
        return avg_params
    
    def save_to_file(self, filename):
        """保存调参数据到文件"""
        import json
        with open(filename, 'w') as f:
            json.dump(self.log_data, f, indent=2)
```

### 3. 性能评估方法

```python
def evaluate_compensation_performance(gravity_comp, test_positions):
    """评估重力补偿性能"""
    
    total_score = 0
    
    for position in test_positions:
        # 移动到测试位置
        print(f"移动到测试位置: {position}")
        input("手动移动机械臂，按Enter继续...")
        
        # 记录一段时间内的稳定性
        stability_scores = []
        for _ in range(50):  # 0.5秒采样
            joint_angles = gravity_comp.get_joint_positions()
            # 计算角速度 (简单差分)
            # 理想情况下角速度应该接近0
            angular_velocity = calculate_angular_velocity(joint_angles)
            stability_score = 1.0 / (1.0 + np.sum(np.abs(angular_velocity)))
            stability_scores.append(stability_score)
            time.sleep(0.01)
        
        position_score = np.mean(stability_scores)
        total_score += position_score
        print(f"位置得分: {position_score:.3f}")
    
    average_score = total_score / len(test_positions)
    print(f"总体性能得分: {average_score:.3f}")
    return average_score

def calculate_angular_velocity(current_angles, previous_angles=None, dt=0.01):
    """计算角速度"""
    if previous_angles is None:
        return np.zeros(6)
    
    return np.array(current_angles) - np.array(previous_angles)) / dt
```

## 常见问题诊断和解决

### 1. 振动问题

**现象**: 机械臂在某些位置出现高频振动

**原因分析**:

- kp (位置增益) 过高
- kd (阻尼增益) 过低  
- 补偿力矩计算不准确

**解决方案**:

```python
# 降低控制增益
self.piper.JointMitCtrl(
    joint_id, 0, 0, 
    0.1,  # 降低kp (原来0.3)
    0.1,  # 增加kd (原来0.05)
    compensated_torque
)

# 或者增加力矩滤波
filtered_torque = 0.8 * compensated_torque + 0.2 * previous_torque
```

### 2. 补偿不足

**现象**: 机械臂在某些位置明显下垂

**诊断步骤**:

```python
def diagnose_insufficient_compensation():
    print("=== 补偿不足诊断 ===")
    
    # 1. 检查整体增益
    if compensation_gain < 0.5:
        print("建议: 增加 compensation_gain")
    
    # 2. 检查关键关节参数
    critical_joints = [2, 3, 4]
    for joint_id in critical_joints:
        params = gravity_compensation_params[joint_id]
        if params['base_torque'] < expected_ranges[joint_id]['min']:
            print(f"建议: 增加关节{joint_id}的base_torque")
    
    # 3. 检查负载估计
    print("是否更换了末端工具? 如是，需要重新调参")
```

### 3. 过补偿

**现象**: 机械臂向上漂移或在某些位置反向运动

**解决方案**:

```python
def fix_overcompensation():
    # 逐步降低补偿
    compensation_gain *= 0.9
    
    # 或者降低主要关节的base_torque
    gravity_compensation_params[2]['base_torque'] *= 0.9
    gravity_compensation_params[3]['base_torque'] *= 0.9
```

## 自动调参算法

### 1. 遗传算法优化

```python
import random

class GeneticParameterOptimizer:
    def __init__(self, gravity_comp, population_size=20):
        self.gravity_comp = gravity_comp
        self.population_size = population_size
        self.mutation_rate = 0.1
        self.crossover_rate = 0.8
        
    def generate_random_params(self):
        """生成随机参数个体"""
        return {
            2: {
                'base_torque': random.uniform(1.0, 4.0),
                'pos_factor': random.uniform(0.5, 2.5)
            },
            3: {
                'base_torque': random.uniform(0.5, 2.0),
                'pos_factor': random.uniform(0.3, 1.5)
            },
            4: {
                'base_torque': random.uniform(0.1, 0.8),
                'pos_factor': random.uniform(0.1, 0.8)
            }
        }
    
    def crossover(self, parent1, parent2):
        """参数交叉"""
        child = {}
        for joint_id in [2, 3, 4]:
            if random.random() < self.crossover_rate:
                child[joint_id] = parent1[joint_id].copy()
            else:
                child[joint_id] = parent2[joint_id].copy()
        return child
    
    def mutate(self, individual):
        """参数变异"""
        for joint_id in [2, 3, 4]:
            if random.random() < self.mutation_rate:
                individual[joint_id]['base_torque'] += random.gauss(0, 0.1)
                individual[joint_id]['pos_factor'] += random.gauss(0, 0.05)
        return individual
    
    def optimize(self, generations=50):
        """运行遗传算法优化"""
        # 初始化种群
        population = [self.generate_random_params() for _ in range(self.population_size)]
        
        for generation in range(generations):
            # 评估适应度
            fitness_scores = []
            for individual in population:
                # 应用参数并测试性能
                self.gravity_comp.gravity_compensation_params.update(individual)
                score = self.evaluate_fitness()
                fitness_scores.append(score)
            
            # 选择、交叉、变异
            new_population = []
            for _ in range(self.population_size):
                parent1 = self.tournament_selection(population, fitness_scores)
                parent2 = self.tournament_selection(population, fitness_scores)
                child = self.crossover(parent1, parent2)
                child = self.mutate(child)
                new_population.append(child)
            
            population = new_population
            print(f"第{generation}代，最佳适应度: {max(fitness_scores):.3f}")
        
        # 返回最佳个体
        best_idx = fitness_scores.index(max(fitness_scores))
        return population[best_idx]
```

### 2. 梯度下降优化

```python
class GradientOptimizer:
    def __init__(self, gravity_comp):
        self.gravity_comp = gravity_comp
        self.learning_rate = 0.01
        
    def compute_gradient(self, params, test_positions):
        """计算参数梯度"""
        gradients = {}
        epsilon = 0.01  # 数值微分步长
        
        base_score = self.evaluate_params(params, test_positions)
        
        for joint_id in [2, 3, 4]:
            gradients[joint_id] = {}
            
            # base_torque梯度
            params_plus = params.copy()
            params_plus[joint_id]['base_torque'] += epsilon
            score_plus = self.evaluate_params(params_plus, test_positions)
            gradients[joint_id]['base_torque'] = (score_plus - base_score) / epsilon
            
            # pos_factor梯度
            params_plus = params.copy()
            params_plus[joint_id]['pos_factor'] += epsilon
            score_plus = self.evaluate_params(params_plus, test_positions)
            gradients[joint_id]['pos_factor'] = (score_plus - base_score) / epsilon
        
        return gradients
    
    def optimize_step(self, params, gradients):
        """执行一步梯度下降"""
        for joint_id in [2, 3, 4]:
            params[joint_id]['base_torque'] += self.learning_rate * gradients[joint_id]['base_torque']
            params[joint_id]['pos_factor'] += self.learning_rate * gradients[joint_id]['pos_factor']
        
        return params
```

## 参数保存和管理

### 1. 参数配置文件管理

```python
import json
import os
from datetime import datetime

class ParameterManager:
    def __init__(self, config_dir="./gravity_compensation_configs"):
        self.config_dir = config_dir
        os.makedirs(config_dir, exist_ok=True)
    
    def save_configuration(self, params, metadata=None):
        """保存参数配置"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"gravity_comp_config_{timestamp}.json"
        filepath = os.path.join(self.config_dir, filename)
        
        config = {
            'timestamp': timestamp,
            'parameters': params,
            'metadata': metadata or {}
        }
        
        with open(filepath, 'w') as f:
            json.dump(config, f, indent=2)
        
        print(f"配置已保存到: {filepath}")
        return filepath
    
    def load_configuration(self, filename=None):
        """加载参数配置"""
        if filename is None:
            # 加载最新配置
            config_files = [f for f in os.listdir(self.config_dir) if f.endswith('.json')]
            if not config_files:
                return None
            filename = max(config_files)
        
        filepath = os.path.join(self.config_dir, filename)
        with open(filepath, 'r') as f:
            config = json.load(f)
        
        return config['parameters']
    
    def list_configurations(self):
        """列出所有配置"""
        config_files = [f for f in os.listdir(self.config_dir) if f.endswith('.json')]
        config_files.sort(reverse=True)
        
        print("可用配置:")
        for i, filename in enumerate(config_files):
            print(f"{i+1}. {filename}")
        
        return config_files
```

### 2. 场景化参数配置

```python
class ScenarioParameterManager:
    def __init__(self):
        self.scenarios = {
            'default': {
                'description': '默认标准负载',
                'parameters': {
                    2: {'base_torque': 2.5, 'pos_factor': 1.8},
                    3: {'base_torque': 1.2, 'pos_factor': 0.9},
                    4: {'base_torque': 0.3, 'pos_factor': 0.4},
                },
                'compensation_gain': 0.7
            },
            'light_tool': {
                'description': '轻量工具 (<0.5kg)',
                'parameters': {
                    2: {'base_torque': 2.0, 'pos_factor': 1.5},
                    3: {'base_torque': 1.0, 'pos_factor': 0.8},
                    4: {'base_torque': 0.2, 'pos_factor': 0.3},
                },
                'compensation_gain': 0.6
            },
            'heavy_tool': {
                'description': '重型工具 (>1kg)',
                'parameters': {
                    2: {'base_torque': 3.5, 'pos_factor': 2.2},
                    3: {'base_torque': 2.0, 'pos_factor': 1.3},
                    4: {'base_torque': 0.6, 'pos_factor': 0.6},
                },
                'compensation_gain': 0.8
            },
            'precision_work': {
                'description': '精密作业模式',
                'parameters': {
                    2: {'base_torque': 2.2, 'pos_factor': 1.6},
                    3: {'base_torque': 1.1, 'pos_factor': 0.85},
                    4: {'base_torque': 0.25, 'pos_factor': 0.35},
                },
                'compensation_gain': 0.5  # 降低增益提高稳定性
            }
        }
    
    def load_scenario(self, scenario_name):
        """加载场景参数"""
        if scenario_name not in self.scenarios:
            print(f"场景 '{scenario_name}' 不存在")
            return None
        
        scenario = self.scenarios[scenario_name]
        print(f"加载场景: {scenario['description']}")
        return scenario
    
    def create_custom_scenario(self, name, description, parameters, gain):
        """创建自定义场景"""
        self.scenarios[name] = {
            'description': description,
            'parameters': parameters,
            'compensation_gain': gain
        }
        print(f"创建自定义场景: {name}")
```

这个详细的调参指南提供了：

1. **理论基础**: 重力补偿的数学原理和简化模型
2. **系统性方法**: 分阶段的调参流程
3. **实用工具**: 实时调参界面和数据记录
4. **高级技术**: 自适应算法和自动优化
5. **问题诊断**: 常见问题的识别和解决方案
6. **参数管理**: 配置保存和场景化管理

通过这套完整的调参体系，您可以高效地为Piper机械臂配置最优的重力补偿参数。
